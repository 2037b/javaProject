## FirstTry.java

1. 假设增加线程先进入，得到的hp是10000
2. 进行增加运算
3. 正在做增加运算的时候，还没有来得及修改hp的值，减少线程来了
4. 减少线程得到的hp的值也是10000
5. 减少线程进行减少运算
6. 增加线程运算结束，得到值10001，并把这个值赋予hp
7. 减少线程也运算结束，得到值9999，并把这个值赋予hp

>hp，最后的值就是9999，虽然经历了两个线程各自增减了一次，本来期望还是原值10000，但是却得到了一个9999这个时候的值9999是一个错误的值，在业务上又叫做 **脏数据**。

## GetKnowSynchronized.java

初识synchronized关键字：  
synchronized(someObject) 表示当前线程，独占 对象 someObject ，如果有其他线程试图占有对象someObject，就会等待，直到当前线程释放对someObject的占用。someObject 又叫同步对象，所有的对象，都可以作为同步对象，为了达到同步的效果，必须使用同一个同步对象。

* synchronized 同步锁，属于 访问控制修饰符。

>释放同步对象的方式： synchronized 块自然结束，或者有异常抛出。

### more about synchronized

如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类。  
同一时间，只有一个线程能够进入 这种类的一个实例 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)。
